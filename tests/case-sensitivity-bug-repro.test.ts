/**
 * Test to reproduce the case sensitivity validation bug discovered in issue
 *
 * Bug Summary:
 * 1. Truncation artifact: sqlPreview shows "OR" which is truncated "ORDER BY"
 * 2. Case sensitivity: Pattern validation may fail on case mismatches
 *
 * Expected behavior: PostgreSQL listTables() should work regardless of case
 */

import { describe, it, expect } from 'vitest';
import { PostgresConnector } from '../src/connectors/postgres.js';
import type { ConnectorConfig } from '../src/types/connector.js';

describe('Case Sensitivity Bug Reproduction', () => {
  const config: ConnectorConfig = {
    host: 'localhost',
    port: 5432,
    database: 'test_db',
    username: 'test_user',
    password: 'test_password',
    ssl: true  // Fix: SSL required in default config
  };

  const configWithDisabledSSL: ConnectorConfig = {
    host: 'localhost',
    port: 5432,
    database: 'test_db',
    username: 'test_user',
    password: 'test_password',
    ssl: false
  };

  describe('SQL Preview Truncation Issue', () => {
    it('should show how sqlPreview truncation creates "OR" artifact', () => {
      const fullSQL = `
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = $1
        ORDER BY table_name
        LIMIT $2
      `.trim();

      // Simulate the sqlPreview truncation (first 100 chars)
      const preview = fullSQL.substring(0, 100);
      console.log('Full SQL:', fullSQL);
      console.log('SQL Preview (100 chars):', JSON.stringify(preview));
      console.log('Preview ends with OR:', preview.trim().endsWith('OR'));

      // Test various truncation points
      for (let i = 80; i <= 120; i++) {
        const truncated = fullSQL.substring(0, i);
        if (truncated.trim().endsWith('OR')) {
          console.log(`Truncation at ${i} chars creates "OR" artifact:`, JSON.stringify(truncated.trim()));
        }
      }
    });
  });

  describe('Case Sensitivity Pattern Matching', () => {
    it('should test pattern matching against case variations', () => {
      const patterns = [
        /^SELECT\s+.+?\s+FROM\s+information_schema\./is,
        /^SELECT[\s\S]+?FROM[\s\S]+?information_schema\./is,
        /^SELECT[\s\S]+?FROM[\s\S]*`[^`]*\.INFORMATION_SCHEMA\./is
      ];

      const testQueries = {
        lowercase: 'SELECT table_name FROM information_schema.tables WHERE table_schema = $1',
        uppercase: 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = $1',
        mixed: 'SELECT table_name FROM Information_Schema.Tables WHERE table_schema = $1',
        multiline_lower: `
          SELECT table_name
          FROM information_schema.tables
          WHERE table_schema = $1
          ORDER BY table_name
          LIMIT $2
        `,
        multiline_upper: `
          SELECT TABLE_NAME
          FROM INFORMATION_SCHEMA.TABLES
          WHERE TABLE_SCHEMA = $1
          ORDER BY TABLE_NAME
          LIMIT $2
        `
      };

      // Test each pattern against each query variation
      Object.entries(testQueries).forEach(([name, sql]) => {
        console.log(`\n=== Testing ${name} ===`);
        console.log('SQL:', sql.trim());

        patterns.forEach((pattern, index) => {
          const matches = pattern.test(sql);
          console.log(`Pattern ${index + 1}: ${matches ? 'MATCH' : 'NO MATCH'}`);

          if (!matches) {
            console.log(`  Pattern: ${pattern.source}`);
            console.log(`  Flags: ${pattern.flags}`);
          }
        });

        // Test if issue is with normalization
        const normalized = sql.trim().toUpperCase();
        console.log('Normalized SQL:', normalized.substring(0, 80) + '...');

        patterns.forEach((pattern, index) => {
          const normalizedMatches = pattern.test(normalized);
          console.log(`Pattern ${index + 1} vs normalized: ${normalizedMatches ? 'MATCH' : 'NO MATCH'}`);
        });
      });
    });
  });

  describe('PostgreSQL Connector Validation', () => {
    it('should validate the exact SQL generated by listTables()', async () => {
      const connector = new PostgresConnector(config, { requireSSL: false });

      // Get the exact SQL that would be generated (without executing)
      const expectedSQL = `
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = $1
        ORDER BY table_name
        LIMIT $2
      `;

      console.log('\n=== PostgreSQL listTables() SQL Validation ===');
      console.log('Expected SQL:', expectedSQL.trim());

      // Test validateQuery method directly
      try {
        // This should work if patterns are correct
        await (connector as any).validateQuery(expectedSQL.trim());
        console.log('✅ Validation PASSED');
      } catch (error) {
        console.log('❌ Validation FAILED:', error instanceof Error ? error.message : error);

        // Additional debugging
        const normalized = expectedSQL.trim().toUpperCase();
        console.log('Normalized SQL:', normalized);

        // Test the specific patterns
        const patterns = [
          /^SELECT\s+.+?\s+FROM\s+information_schema\./is,
          /^SELECT[\s\S]+?FROM[\s\S]+?information_schema\./is
        ];

        patterns.forEach((pattern, index) => {
          console.log(`Pattern ${index + 1} test on original:`, pattern.test(expectedSQL.trim()));
          console.log(`Pattern ${index + 1} test on normalized:`, pattern.test(normalized));
        });
      }
    });

    it('should test listTables() method if connection is available', async () => {
      const connector = new PostgresConnector(configWithDisabledSSL, { requireSSL: false });

      console.log('\n=== PostgreSQL listTables() Execution Test ===');

      try {
        // This will fail with connection error, but we're interested in validation errors
        await connector.listTables();
        console.log('✅ listTables() succeeded (unexpected - no real DB)');
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.log('listTables() error:', errorMessage);

        // Check if it's a validation error vs connection error
        if (errorMessage.includes('Query pattern not allowed')) {
          console.log('❌ BUG CONFIRMED: Query pattern validation failed');
        } else if (errorMessage.includes('connection') || errorMessage.includes('Connection')) {
          console.log('✅ Expected connection error (validation passed)');
        } else {
          console.log('⚠️  Unexpected error type');
        }
      }
    });
  });

  describe('Edge Cases and Truncation Scenarios', () => {
    it('should test SQL queries at various truncation points', () => {
      const baseSQL = 'SELECT table_name FROM information_schema.tables WHERE table_schema = $1 ORDER BY table_name LIMIT $2';

      console.log('\n=== Truncation Edge Cases ===');
      console.log('Base SQL:', baseSQL);
      console.log('Length:', baseSQL.length);

      // Test truncation at different points
      const criticalPoints = [95, 96, 97, 98, 99, 100, 101, 102, 103];

      criticalPoints.forEach(point => {
        const truncated = baseSQL.substring(0, point);
        const endsWithOR = /OR\s*$/.test(truncated);
        const endsWithIncompleteClause = /\b(WHERE|AND|OR|JOIN|ON|SET|VALUES)\s*$/.test(truncated);

        console.log(`Point ${point}: "${truncated.slice(-10)}" | EndsWithOR: ${endsWithOR} | Incomplete: ${endsWithIncompleteClause}`);
      });
    });
  });
});